'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @param {Number} n
 * @returns {Generator}
 */
const chunk = (n) => function*(iterator) {
  let i = 0;
  let acc = [];

  for (let value of iterator) {
    acc.push(value);
    if (++i >= n) {
      yield acc;
      acc = [];
      i = 0;
    }
  }

  if (acc.length > 0) {
    yield acc;
  }
};

/**
 * @param {Number} n
 * @returns {Generator}
 */
const drop = (n = 1) => function *(iterator) {
  let i = 0;

  for (let value of iterator) {
    if (i++ >= n) {
      yield value;
    }
  }
};

/**
 * @param {Function} fn
 * @returns {Generator}
 */
const filter = (fn) => function*(iterator) {
  for (let value of iterator) {
    if (fn(value)) {
      yield value;
    }
  }
};

/**
 * @param {Function} fn
 * @returns {Generator}
 */
const map = (fn) => function*(iterator) {
  for (let value of iterator) {
    yield fn(value);
  }
};

/**
 * @type {Generator}
 */
const tail = drop(1);

/**
 * @param {Number} count
 * @returns {Generator}
 */
const take = (count) => function*(iterator) {
  let i = 0;
  for (let value of iterator) {
    if (i++ < count) {
      yield value;
    } else {
      return;
    }
  }
};

/**
 * @param {Iterable} iterator
 */
function* reverse(iterator) {
  yield* [...iterator].reverse();
}

/**
 * @param {Function} fn
 * @returns {Generator}
 */
const sort = (fn = null) => function*(iterator) {
  yield* [...iterator].sort(fn);
};


/**
 * @param {Iterable} iterator
 */
function* zip(iterator) {
  const values = [...iterator];
  const length = Math.max(...values.map(x => x.length));

  for (let i = 0; i < length; i++) {
    yield values
      .map(x => x[i])
      .filter(x => x !== undefined && x !== null);
  }
}

/**
 * @method {Chain} top
 */
class Chain {
  /**
   * @param {Iterable} iterator
   */
  constructor(iterator) {
    this.iterator = function*() {
      yield* iterator;
    }();
  }

  /**
   * @returns {Iterable}
   */
  [Symbol.iterator]() {
    return this.iterator;
  }

  /**
   * @param {Function} fn
   */
  forEach(fn) {
    for (let value of this.iterator) {
      fn(value);
    }
  }

  /**
   * @returns {Array}
   */
  toArray() {
    const array = [];

    for (let value of this.iterator) {
      array.push(value);
    }

    return array;
  }

  /**
   * @returns {*}
   */
  head() {
    return this.iterator.next().value;
  }


  /**************************************
   *        Chainable methods           *
   **************************************/

  /**
   * @param {Function|Generator} fn
   * @returns {Chain}
   */
  apply(fn) {
    this.iterator = fn(this.iterator);
    return this;
  }

  /**
   * @param {Generator} fn
   * @returns {Chain}
   */
  compose(...fn) {
    for (let f of fn) {
      this.iterator = f(this.iterator);
    }
    return this;
  }

  /**
   * @param {Number} n
   * @returns {Chain}
   */
  chunk(n) {
    return this.apply(chunk(n));
  }

  /**
   * @param {Number} n
   * @returns {Chain}
   */
  drop(n = 1) {
    return this.apply(drop(n));
  }

  /**
   * @param {Function} fn
   * @returns {Chain}
   */
  filter(fn) {
    return this.apply(filter(fn));
  }

  /**
   * @param {Function} fn
   * @returns {Chain}
   */
  map(fn) {
    return this.apply(map(fn));
  }

  /**
   * @returns {Chain}
   */
  tail() {
    return this.apply(tail);
  }

  /**
   * @param {Number} count
   * @returns {Chain}
   */
  take(count) {
    return this.apply(take(count));
  }

  /**
   * @returns {Chain}
   */
  reverse() {
    return this.apply(reverse);
  }

  /**
   * @param {Function} fn
   * @returns {Chain}
   */
  sort(fn = null) {
    return this.apply(sort(fn));
  }

  /**
   * @returns {Chain}
   */
  zip() {
    return this.apply(zip)
  }
}

/**
 * @param {Number} start
 * @param {Number} end
 * @param {Number} step
 * @returns {Chain}
 */
function range(start = 0, end = Infinity, step = 1) {
  const iterator = (function*() {
    for (let i = start; i <= end; i += step) {
      yield i;
    }
  })();
  return new Chain(iterator);
}

/**
 * @param {Generator} fn
 * @returns {Generator}
 */
function compose(...fn) {
  return function*(iterator) {
    for (let f of fn) {
      iterator = f(iterator);
    }
    yield* iterator;
  }
}

/**
 * @param params
 * @returns {Chain}
 */
function fx(...params) {
  return new Chain(params.length === 1 ? params[0] : params);
}

exports.fx = fx;
exports.range = range;
exports.compose = compose;
exports.chunk = chunk;
exports.drop = drop;
exports.filter = filter;
exports.map = map;
exports.tail = tail;
exports.take = take;
exports.reverse = reverse;
exports.sort = sort;
exports.zip = zip;