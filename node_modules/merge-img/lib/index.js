'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _jimp = require('jimp');

var _jimp2 = _interopRequireDefault(_jimp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function mergeImg(images) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!Array.isArray(images)) {
    throw new TypeError('`images` must be an array contains images');
  }

  if (images.length < 1) {
    throw new Error('At least `images` must contain more than one image');
  }

  var _opts$direction = opts.direction,
      direction = _opts$direction === undefined ? false : _opts$direction,
      _opts$color = opts.color,
      color = _opts$color === undefined ? 0x00000000 : _opts$color,
      _opts$align = opts.align,
      align = _opts$align === undefined ? 'center' : _opts$align,
      _opts$offset = opts.offset,
      offset = _opts$offset === undefined ? 0 : _opts$offset;


  return Promise.all(images.map(function (img) {
    return (0, _jimp.read)(img);
  })).then(function (imgs) {
    var totalX = 0;
    var totalY = 0;

    var imgData = imgs.reduce(function (res, elem) {
      var _elem$bitmap = elem.bitmap,
          width = _elem$bitmap.width,
          height = _elem$bitmap.height;


      res.push({
        img: elem,
        prevX: totalX,
        prevY: totalY
      });

      totalX += width;
      totalY += height;

      return res;
    }, []);

    var totalWidth = direction ? Math.max.apply(Math, _toConsumableArray(imgs.map(function (_ref) {
      var width = _ref.bitmap.width;
      return width;
    }))) : imgs.reduce(function (res, _ref2) {
      var width = _ref2.bitmap.width;
      return res + width;
    }, 0) + (imgs.length - 1) * offset;

    var totalHeight = direction ? imgs.reduce(function (res, _ref3) {
      var height = _ref3.bitmap.height;
      return res + height;
    }, 0) + (imgs.length - 1) * offset : Math.max.apply(Math, _toConsumableArray(imgs.map(function (_ref4) {
      var height = _ref4.bitmap.height;
      return height;
    })));

    var baseImage = new _jimp2.default(totalWidth, totalHeight, color);

    var alignImage = function alignImage(total, size) {
      if (align === 'center') {
        return (total - size) / 2;
      }

      if (align === 'end') {
        return total - size;
      }

      return 0;
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = imgData.map(function (elem, idx) {
        return [idx, elem];
      })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _ref5 = _step.value;

        var _ref6 = _slicedToArray(_ref5, 2);

        var index = _ref6[0];
        var _ref6$ = _ref6[1];
        var img = _ref6$.img;
        var prevX = _ref6$.prevX;
        var prevY = _ref6$.prevY;
        var _img$bitmap = img.bitmap,
            width = _img$bitmap.width,
            height = _img$bitmap.height;

        var _ref7 = direction ? [alignImage(totalWidth, width), prevY + index * offset] : [prevX + index * offset, alignImage(totalHeight, height)],
            _ref8 = _slicedToArray(_ref7, 2),
            px = _ref8[0],
            py = _ref8[1];

        baseImage.composite(img, px, py);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return baseImage;
  });
}

exports.default = mergeImg;
module.exports = exports['default'];