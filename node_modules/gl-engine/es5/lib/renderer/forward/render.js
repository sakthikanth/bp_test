'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = renderForwardScene;

var _updateShaders = require('./update-shaders');

var _updateShaders2 = _interopRequireDefault(_updateShaders);

var _renderDone = require('../../scene/render-done');

var _renderDone2 = _interopRequireDefault(_renderDone);

var _clear = require('./clear');

var _clear2 = _interopRequireDefault(_clear);

var _updateLights = require('./update-lights');

var _updateLights2 = _interopRequireDefault(_updateLights);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderForwardScene(renderer, shaderCache, scene, camera) {
  var gl = renderer.gl;
  var meshes = scene.getByType('mesh');
  var lights = scene.getByType('light');

  gl.enable(gl.DEPTH_TEST);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  (0, _clear2.default)(gl, renderer.clear);

  if (scene.flags.changed) {
    (0, _updateShaders2.default)(renderer.gl, shaderCache, meshes, lights, scene);
  }

  scene.updateTransforms();

  camera.update(renderer.canvas);
  (0, _updateLights2.default)(lights);

  renderer.emitter.emit('beforerender');

  for (var i = 0; i < meshes.length; i++) {
    var mesh = meshes[i];
    var material = mesh.material;
    var geometry = mesh.geometry;

    if (material && geometry) {
      if (material.shader.attributes.aNormal) {
        camera.updateModelView(mesh.transform.global);
        camera.updateNormal();
      }

      geometry.buffers.bind(material.shader);
      material.setUniforms.forEach(function (fn) {
        return fn(material.shader, camera, mesh, lights);
      });
      geometry.buffers.draw(gl[material.mode]);
      geometry.buffers.unbind();
    }
  }

  renderer.emitter.emit('afterrender');

  (0, _renderDone2.default)(scene);
}