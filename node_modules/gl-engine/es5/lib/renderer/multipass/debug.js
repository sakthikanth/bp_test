'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createDebugger;

var _glFbo = require('gl-fbo');

var _glFbo2 = _interopRequireDefault(_glFbo);

var _glShader = require('gl-shader');

var _glShader2 = _interopRequireDefault(_glShader);

var _glBuffer = require('gl-buffer');

var _glBuffer2 = _interopRequireDefault(_glBuffer);

var _glVao = require('gl-vao');

var _glVao2 = _interopRequireDefault(_glVao);

var _aBigTriangle = require('a-big-triangle');

var _aBigTriangle2 = _interopRequireDefault(_aBigTriangle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MARGIN = 0.05;

function drawPassShader(gl) {
  return (0, _glShader2.default)(gl, ' #define SHADER_NAME drawPass\n      #define MARGIN ' + MARGIN + '\n\n      attribute vec2 aPosition;\n\n      uniform vec2 uScale;\n      uniform vec2 uOffset;\n      uniform vec2 uResolution;\n\n      varying vec2 vUv;\n\n      void main() {\n        vec2 position = (aPosition * 0.5 + 0.5); // [-1, 1] -> [0, 1]\n        // vUv = position * uScale - vec2(30.45, 425.0) / vec2(609.0, 774.0);\n        vUv = (position - uOffset) * uScale;\n\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n      }\n    ', ' precision mediump float;\n      #define SHADER_NAME drawPass\n\n      uniform sampler2D uInput;\n\n      varying vec2 vUv;\n\n      void main() {\n        gl_FragColor = texture2D(uInput, vUv);\n      }\n  ');
}

// Draw a small thumbnail image of the output
function drawPass(bindings, passIndex, passCount, outputFBO) {
  var debugFBO = bindings.debugFBO;
  var gl = bindings.gl;
  var canvas = bindings.canvas;
  var shader = bindings.shader;
  var quad = bindings.quad;
  var resolution = bindings.resolution;
  var scale = bindings.scale;
  var offset = bindings.offset;
  var uniforms = shader.uniforms;
  var width = canvas.width;
  var height = canvas.height;

  debugFBO.bind();
  shader.bind();

  // update shader
  var resizeResolutionX = width / passCount * (1 - MARGIN * 2);
  var resizeResolutionY = height / passCount * (1 - MARGIN * 2);
  resolution[0] = width;
  resolution[1] = height;
  scale[0] = width / resizeResolutionX;
  scale[1] = height / resizeResolutionY;
  var scissorOffsetX = width * passIndex / passCount + width / passCount * MARGIN;
  var scissorOffsetY = height / 2 - resizeResolutionY / 2;
  offset[0] = scissorOffsetX / width;
  offset[1] = scissorOffsetY / height;
  uniforms.uOffset = offset;
  uniforms.uResolution = resolution;
  uniforms.uScale = scale;
  uniforms.uInput = outputFBO.color[0].bind(0);

  // set scissor
  gl.enable(gl.SCISSOR_TEST);
  gl.scissor(
  // coordinate of lower left of box, moving up and to the right
  scissorOffsetX, scissorOffsetY, resizeResolutionX, resizeResolutionY);

  // clear first, then draw on it
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.disable(gl.DEPTH_TEST);
  (0, _aBigTriangle2.default)(gl);

  // reset state
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.disable(gl.SCISSOR_TEST);
  gl.enable(gl.DEPTH_TEST);
  gl.scissor(0, 0, width, height);
}

function drawToScreenShader(gl) {
  return (0, _glShader2.default)(gl, ' #define SHADER_NAME drawToScreen\n\n      attribute vec2 aPosition;\n      varying vec2 vUv;\n\n      void main() {\n        vUv = aPosition * 0.5 + 0.5;\n        gl_Position = vec4(aPosition, -1.0, 1.0);\n      }\n    ', ' precision mediump float;\n      #define SHADER_NAME drawToScreen\n\n      uniform sampler2D uInput;\n      varying vec2 vUv;\n\n      void main() {\n        vec4 frag = texture2D(uInput, vUv);\n        if(frag.a == 0.0) {\n          discard;\n        } else {\n          gl_FragColor = texture2D(uInput, vUv);\n        }\n      }\n  ');
}

function drawToScreen(bindings, finalFBO) {
  var debugFBO = bindings.debugFBO;
  var shader = bindings.shader;
  var gl = bindings.gl;

  gl.disable(gl.DEPTH_TEST);

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  shader.bind();
  shader.uniforms.uInput = finalFBO.color[0].bind(1);
  (0, _aBigTriangle2.default)(gl);

  shader.uniforms.uInput = debugFBO.color[0].bind(2);
  (0, _aBigTriangle2.default)(gl);
  gl.disable(gl.DEPTH_TEST);
}

function createDebugger(gl) {
  var canvas = gl.canvas;
  var debugFBO = (0, _glFbo2.default)(gl, [canvas.width, canvas.height]);
  var quad = (0, _glVao2.default)(gl, [{
    buffer: (0, _glBuffer2.default)(gl, new Float32Array([-1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1])),
    type: gl.FLOAT,
    size: 2
  }]);

  return {
    drawPass: drawPass.bind(null, {
      debugFBO: debugFBO,
      gl: gl,
      quad: quad,
      canvas: canvas,
      shader: drawPassShader(gl),
      resolution: [],
      scale: [],
      offset: []
    }),
    drawToScreen: drawToScreen.bind(null, {
      debugFBO: debugFBO,
      gl: gl,
      shader: drawToScreenShader(gl)
    })
  };
}