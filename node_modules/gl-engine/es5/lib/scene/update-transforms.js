'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                   * Generate the global transforms of all the nodes in the graph. This works
                                                                                                                                                                                                                                                   * recursively. Nodes don't necessarily have transforms, so these will pass
                                                                                                                                                                                                                                                   * through the parent matrix, or use an identity matrix for top level nodes.
                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                   * Nodes don't have to auto-update, and will be skipped over.
                                                                                                                                                                                                                                                   */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.walkAndUpdateTransforms = walkAndUpdateTransforms;
exports.default = updateGlobalTransforms;

var _update = require('../transform/update');

var _update2 = _interopRequireDefault(_update);

var _glMat = require('gl-mat4');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IDENTITY = (0, _glMat.identity)(Array(16));

function walkAndUpdateTransforms(graph, children, parentMatrix) {
  for (var i = 0; i < children.length; i++) {
    var nextMatrix = parentMatrix;
    var node = children[i];

    if (_typeof(node.transform) === 'object') {
      if (node.transform.flags.autoUpdate) {
        (0, _update2.default)(node.transform);

        var localMatrix = node.transform.local;
        var globalMatrix = node.transform.global;

        (0, _glMat.multiply)(globalMatrix, parentMatrix, localMatrix);
        nextMatrix = globalMatrix;
      } else {
        nextMatrix = node.transform.global;
      }
    }

    walkAndUpdateTransforms(graph, graph.children.get(node), nextMatrix);
  }
}

function updateGlobalTransforms(scene, graph) {
  var children = graph.children.get(scene);

  // Start recursing through all the first level items in the scene
  // Provide an identity matrix as the base if no transform exists
  // Copy over the local transform to global

  for (var i = 0; i < children.length; i++) {
    var node = children[i];
    var nextMatrix = IDENTITY;

    if (_typeof(node.transform) === 'object') {
      if (node.transform.flags.autoUpdate) {
        (0, _update2.default)(node.transform);
        (0, _glMat.copy)(node.transform.global, node.transform.local);
      }

      nextMatrix = node.transform.global;
    }

    walkAndUpdateTransforms(graph, scene.children(node), nextMatrix);
  }
}