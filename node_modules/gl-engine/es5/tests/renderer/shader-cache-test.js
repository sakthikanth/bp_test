'use strict';

var _tape = require('tape');

var _tape2 = _interopRequireDefault(_tape);

var _lib = require('../../lib');

var _shaderCache = require('../../lib/renderer/shader-cache');

var _shaderCache2 = _interopRequireDefault(_shaderCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _tape2.default)('Shader Cache', function (t) {
  t.plan(7);
  var renderer = (0, _lib.ForwardRenderer)({
    autoAddCanvas: false
  });
  var cache = (0, _shaderCache2.default)();
  var meshA = (0, _lib.Mesh)((0, _lib.Geometry)(), (0, _lib.FlatMaterial)());
  var meshB = (0, _lib.Mesh)((0, _lib.Geometry)(), (0, _lib.FlatMaterial)());

  var shaderA = cache.getOrCreate(renderer.gl, meshA, '');
  var shaderB = cache.getOrCreate(renderer.gl, meshB, '');

  var shaderA2 = cache.getOrCreate(renderer.gl, meshA, '');
  var shaderB2 = cache.getOrCreate(renderer.gl, meshB, '');

  t.equal(shaderA, shaderB, 'Caches the shader across meshes');
  t.equal(shaderA, shaderA2, 'Caches the shader across time');
  t.equal(shaderB, shaderB2, 'Caches the shader across time');

  cache.clearMeshes();

  var shaderA3 = cache.getOrCreate(renderer.gl, meshA, '');

  t.equal(shaderA, shaderA3, 'Cache retains the copy after clearMeshes');
  t.equal(shaderB, shaderA3, 'Cache retains the copy after clearMeshes');

  cache.clearMeshes();
  cache.clearUnused();

  var shaderA4 = cache.getOrCreate(renderer.gl, meshA, '');

  t.notEqual(shaderA, shaderA4, 'Does not retain cache if no meshes used it previously');
  t.notEqual(shaderB, shaderA4, 'Does not retain cache if no meshes used it previously');

  renderer.destroy();
});